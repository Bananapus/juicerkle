package main

import (
	"context"
	"encoding/json"
	"fmt"
	"math/big"
	"os"
	"os/exec"
	"path/filepath"
	"sync"
	"testing"
	"time"

	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/ethclient"
)

/*
- Set up a local mainnet fork AND a local Optimism fork.
- Deploy the latest `nana-core` to both forks.
- Deploy a sucker to project #1.
- Claim from several wallets, using the proofs generated by `juicerkle`.
*/

func TestE2E(t *testing.T) {
	// Read test config from 'test_config.json'
	var testConfig struct {
		MainnetRPC  string `json:"mainnetRPC"`
		OptimismRPC string `json:"optimismRPC"`
	}
	testConfigFile, err := os.ReadFile("test_config.json")
	if err != nil {
		t.Fatalf("Failed to open 'test_config.json': %v", err)
	}
	if err := json.Unmarshal(testConfigFile, &testConfig); err != nil {
		t.Fatalf("Failed to decode 'test_config.json': %v", err)
	}

	// Make sure the necessary tools are installed
	tools := []string{"git", "forge", "anvil", "npm", "npx"}
	for _, tool := range tools {
		if _, err := exec.LookPath(tool); err != nil {
			t.Fatalf("Could not find '%s' executable in path: %v", tool, err)
		}
	}

	// Set up mainnet fork
	mainnetChainId := big.NewInt(1)
	mainnetPort := "8545"
	mainnetCmd := exec.Command("anvil", "--fork-url", testConfig.MainnetRPC, "--chain-id", mainnetChainId.String(),
		"--port", mainnetPort, "--silent", "--auto-impersonate")
	if err := mainnetCmd.Start(); err != nil {
		t.Fatalf("Failed to launch mainnet fork: %v", err)
	}
	defer mainnetCmd.Process.Kill()

	// Set up op fork
	opChainId := big.NewInt(10)
	opPort := "8546"
	opCmd := exec.Command("anvil", "--fork-url", testConfig.OptimismRPC, "--chain-id", opChainId.String(),
		"--port", opPort, "--silent", "--auto-impersonate", "--optimism")
	if err := opCmd.Start(); err != nil {
		t.Fatalf("Failed to launch op fork: %v", err)
	}
	defer opCmd.Process.Kill()

	// Dial the forks
	deadline := time.Now().Add(time.Second * 10)
	var mainnetClient, opClient *ethclient.Client
	var mainnetErr, opErr error
	for time.Now().Before(deadline) { // Retry until the deadline
		time.Sleep(time.Second)
		mainnetClient, mainnetErr = ethclient.Dial("http://localhost:" + mainnetPort)
		opClient, opErr = ethclient.Dial("http://localhost:" + opPort)
	}

	if mainnetErr != nil {
		t.Fatalf("Failed to dial mainnet fork: %v", mainnetErr)
	}
	if opErr != nil {
		t.Fatalf("Failed to dial op fork: %v", opErr)
	}
	defer mainnetClient.Close()
	defer opClient.Close()

	// Testing accounts
	account1 := common.HexToAddress("0x1")
	balanceBefore, err := mainnetClient.BalanceAt(context.Background(), account1, nil)
	if err != nil {
		t.Fatalf("Failed to get balance of account1: %v", err)
	}

	var result bool
	err = mainnetClient.Client().Call(&result, "anvil_setBalance", account1, "0x3635c9adc5dea00000")
	if err != nil {
		t.Fatalf("Failed to set balance: %v", err)
	}

	balanceAfter, err := mainnetClient.BalanceAt(context.Background(), account1, nil)
	if err != nil {
		t.Fatalf("Failed to get balance of account1: %v", err)
	}

	t.Logf("Balance before: %v", balanceBefore)
	t.Logf("Balance after: %v", balanceAfter)
	t.Error("")

	// Create a temporary folder for testing
	tempDir, err := os.MkdirTemp("", "juicerkle-test")
	if err != nil {
		t.Fatalf("Failed to create temp dir: %v", err)
	}
	t.Logf("Temp dir: %s", tempDir)
	defer os.RemoveAll(tempDir)

	// Set RPC endpoints for deployments
	os.Setenv("RPC_ETHEREUM_MAINNET", "http://localhost:"+mainnetPort)
	os.Setenv("RPC_OPTIMISM_MAINNET", "http://localhost:"+opPort)
	sphinxArgs := []string{"sphinx", "deploy", "script/Deploy.s.sol", "--confirm", "--silent", "--verify", "false"}

	repos := []struct {
		url           string
		name          string
		deployCommand string
		deployArgs    []string
	}{
		{
			url:           "https://github.com/Bananapus/nana-core.git",
			name:          "nana-core",
			deployCommand: "npx",
			deployArgs:    sphinxArgs,
		},
		{
			url:           "https://github.com/Bananapus/nana-suckers.git",
			name:          "nana-suckers",
			deployCommand: "npx",
			deployArgs:    sphinxArgs,
		},
	}
	for _, repo := range repos {
		repoPath := filepath.Join(tempDir, repo.name)
		cmd := exec.Command("git", "clone", repo.url, repoPath)
		if err := cmd.Run(); err != nil {
			t.Fatalf("Failed to clone repo '%s': %v", repo.url, err)
		}

		// Install npm dependencies
		cmd = exec.Command("npm", "ci")
		cmd.Dir = repoPath
		if err := cmd.Run(); err != nil {
			t.Fatalf("Failed to run 'npm ci' in '%s': %v", repoPath, err)
		}

		// Deploy to mainnet and optimism concurrently
		var wg sync.WaitGroup
		wg.Add(2)
		errChan := make(chan error, 2)

		go func() {
			defer wg.Done()
			cmd = exec.Command(repo.deployCommand, append(repo.deployArgs, "--network", "ethereum")...)
			cmd.Dir = repoPath
			if err := cmd.Run(); err != nil {
				errChan <- fmt.Errorf("Failed to deploy %s to mainnet with cmd '%s %s --network mainnet': %v", repo.name, repo.deployCommand, repo.deployArgs, err)
			}
		}()
		go func() {
			defer wg.Done()
			cmd = exec.Command(repo.deployCommand, append(repo.deployArgs, "--network", "optimism")...)
			cmd.Dir = repoPath
			if err := cmd.Run(); err != nil {
				errChan <- fmt.Errorf("Failed to deploy %s to optimism with cmd '%s %s --network optimism': %v", repo.name, repo.deployCommand, repo.deployArgs, err)
			}
		}()

		wg.Wait()
		close(errChan)
		for err := range errChan {
			if err != nil {
				t.Fatal(err)
			}
		}

		// Set the nana-core deployment path for the suckers to use
		if repo.name == "nana-core" {
			os.Setenv("NANA_CORE_DEPLOYMENT_PATH", filepath.Join(tempDir, repo.name, "deployments"))
		}

	}

	// Set up testing database
	originalTreeDb := treeDb
	treeDb = "testTrees.db"
	defer func() { treeDb = originalTreeDb }() // reset to default after the test
	if err := initDb(); err != nil {
		t.Fatalf("Failed to initialize database: %v", err)
	}
	defer db.Close()
}
